#!/usr/bin/env node

var server = require("plug-base").pure();
var fetch = require("fetch-agent");
var zlib = require("zlib");
var dojiUI = require("doji-ui");
var qs = require("querystring");
var mime = require("mime-types");
var url = require("url");
var path = require("path");
var iconv = require("iconv-lite");
var ipLib = require("ip");
var fs = require("fs");
var request = require("request");
var argv = require("yargs").argv;
var momoda = require("../index.js");

try {
  var updateNotifier = require("update-notifier");
  var packageJSON = require(__dirname + "/../package.json");
  updateNotifier({pkg: packageJSON}).notify();
}
catch (e) {
}

if (!/^192\.168\.88\.\d+/.test(ipLib.address())) {
  console.log("Please connect Special WIFI!");
  return;
}

var currentClientIP = null;
var currentNetMode = "full";

var PORT = argv.port || argv.p || 9999;
var HTTP_PORT = argv.http || 9080;
var HTTPS_PORT = argv.https || 9443;
var GH = argv.gh || argv.g || 0;
var postUrl = argv.url || argv.u;
var viewUrl = argv.view || argv.v;
if (!/https?:\/\//.test(postUrl)) {
  postUrl = null;
}
if (!/https?:\/\//.test(viewUrl)) {
  viewUrl = null;
}

var userHome = process.env.HOME || process.env.USERPROFILE || process.env.HOMEPATH;
var config = path.join(userHome, "momoda.json");
if (fs.existsSync(config)) {
  var conf = require(config);
  postUrl = postUrl || conf.post;
  viewUrl = viewUrl || conf.view;
}
else {
  fs.writeFileSync(config, JSON.stringify({
    post: postUrl || '',
    view: viewUrl || ''
  }, null, 2));
  fs.chmod(config, 0777);
}

var wss = dojiUI.quickStart(PORT, {
  "/rootca": function (req, res) {
    var rootCAPath = server.getRootCAPath();
    var rootca = path.basename(rootCAPath);
    res.writeHead(200, {
      "Content-Type": mime.lookup(rootca),
      "Content-Disposition": "attachment;filename=" + rootca
    });
    res.end(fs.readFileSync(rootCAPath, {encoding: null}));
  },
  "/client/clear": function (req, res) {
    momoda.clear(ipLib.address(), function () {
      wss.clear();
      currentClientIP = null;
      currentNetMode = "full";
      res.end(JSON.stringify({code: 0}));
    });
  },
  "/client/bind": function (req, res) {
    var needReBind = true;

    if (req.info.query && req.info.query.client) {
      currentClientIP = req.info.query.client;
      needReBind = false;
    }
    else {
      currentClientIP = req.connection.remoteAddress.replace(/.+\:/, '');
    }

    momoda.bind(ipLib.address(), currentClientIP, HTTP_PORT, HTTPS_PORT, function () {
      wss.virtual(currentClientIP);
      wss.broadcast({
        type: "ui",
        event: "client.view",
        data: {
          client: currentClientIP,
          bind: needReBind
        }
      });
      res.end(JSON.stringify({bind: currentClientIP}));
    });
  },
  "/speed": function (req, res) {
    var buff = [];
    req.on("data", function (chunk) {
      buff.push(chunk);
    });
    req.on("end", function () {
      var v = qs.parse(Buffer.concat(buff).toString());
      if (v.up || v.down) {
        momoda.speed(ipLib.address(), v, function () {
          currentNetMode = v.mode || "full";
          res.end(JSON.stringify({code: 0}));
        });
      }
      else {
        res.end(JSON.stringify({code: 500}));
      }
    });

    res.end();
  }
});

momoda.clients(ipLib.address(), function (clients) {
  clients.forEach(function (i) {
    wss.virtual(i['src-address']);
  });
});

function analysis(req, res) {
  var gunzipResBuf = res.buffer;
  var parsed = null;

  var reqInfo = url.parse(req.url, true);
  reqInfo.protocol = reqInfo.protocol || (req.connection.encrypted ? "https:" : "http:");
  reqInfo.host = reqInfo.host || req.headers.host;
  reqInfo.hostname = (reqInfo.host || '').split(':')[0];
  reqInfo.port = reqInfo.port || (req.connection.encrypted ? "443" : "80");

  var charset;
  var extname = path.extname(reqInfo.pathname);
  var ct = (res.headers || {})['content-type'];
  var ajax = (req.headers || {})['x-requested-with'];
  if (ajax || /text|css|javascript|json|xml/.test(ct)) {
    charset = "UTF-8";
  }
  if (ct) {
    var matched = ct.match(/charset\=([^\;]+)\b/i);
    if (matched && matched[1]) {
      if (/javascript/.test(ct)) {
        extname = ".js";
      }
      charset = matched[1];
      ct = ct.replace(/;.+/, '');
    }

    var resExtname = mime.extension(ct);
    if (resExtname) {
      extname = '.' + resExtname;
    }
  }

  if (reqInfo.search.match(/^\?{2}/)) {
    extname = path.extname(reqInfo.search.split(/[\&\?]+/)[1]);
  }
  if (reqInfo.query && (reqInfo.query['jsonp'] || reqInfo.query['callback'])) {
    extname = '.js';
  }

  if (!res.error && charset && res.headers) {
    var encoding = res.headers['content-encoding'];

    if (res.headers && encoding) {
      if (encoding.match(/gzip/i)) {
        gunzipResBuf = zlib.gunzipSync(res.buffer);
      }
      else if (encoding.match(/deflate/i)) {
        gunzipResBuf = zlib.inflateSync(res.buffer);
      }
    }

    if (gunzipResBuf) {
      try {
        parsed = iconv.decode(gunzipResBuf, charset);
      }
      catch (e) {
        parsed = gunzipResBuf.toString();
      }
    }
  }

  var mock = {
    req: {
      headers: req.headers || {},
      cookies: req.headers.cookies || '',
      query: req.query,
      search: qs.stringify(req.query),
      body: req.body || {}
    },
    res: {
      headers: res.headers || {},
      body: {
        size: Buffer.byteLength(res.buffer, charset),
        extname: extname,
        parsed: parsed || "不支持预览"
      }
    },
    times: {
      'wait': '',
      'download': '',
      'req': req.time,
      'during': res.time - req.time
    },
    extname: extname,
    remote: currentClientIP || req.clientIP,
    url: url.format(reqInfo),
    method: req.method.toUpperCase(),
    statusCode: res.statusCode || 500
  };

  wss.broadcast({
    type: "ui",
    event: "network.add",
    data: mock
  });

  if (postUrl) {
    var form = {
      gh: GH,
      host: reqInfo.host || '',
      url: mock.url,
      netType: currentNetMode || "full",
      ip: currentClientIP || req.clientIP,
      req: JSON.stringify({
        headers: req.headers,
        time: req.time
      }),
      resp: JSON.stringify({
        headers: res.headers,
        time: res.time,
        code: res.statusCode
      })
    };
    if (parsed) {
      form.body = parsed;
    }
    request.post({
      url: postUrl,
      form: form
    }, function (err, res, body) {
    });
  }
}

var open = require("open");
if (viewUrl) {
  open(viewUrl);
}
open("http://" + ipLib.address() + ':' + PORT + "/doji/ui/");

server
  .use(function (req, res, next) {
    req.time = (new Date()).valueOf();

    if (req.headers['if-modified-since']) {
      req.headers['if-modified-since'] = null;
      delete req.headers['if-modified-since'];
    }
    if (req.headers['if-none-match']) {
      req.headers['if-none-match'] = null;
      delete req.headers['if-none-match'];
    }

    if (req.headers && req.headers['content-type'] && /xml|json|form/.test(req.headers['content-type'])) {
      var buff = [];
      req.body = {};
      req.on("data", function (chunk) {
        buff.push(chunk);
      });
      req.on("end", function () {
        var content = Buffer.concat(buff);
        try {
          req.body.raw = content.toString();
        }
        catch (e) {}

        if (/json/.test(req.headers['content-type'])) {
          req.body.json = JSON.parse(req.body.raw);
        }
      });
    }

    fetch.proxy(
      req, res,

      function onSuccess(err, buffer, nsres) {
        res.time = (new Date()).valueOf();
        res.headers = nsres.headers || {};
        res.statusCode = nsres.statusCode;
        res.buffer = buffer;

        analysis(req, res);
        next();
      },

      function onError(err) {
        console.log(err.code);

        res.time = (new Date()).valueOf();
        res.statusCode = 500;
        res.error = true;

        analysis(req, res);
        next();
      }
    );
  })
  .listen(HTTP_PORT, HTTPS_PORT);